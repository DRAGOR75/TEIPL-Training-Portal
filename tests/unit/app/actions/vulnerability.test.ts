import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { joinBatch, lockSessionBatch } from '@/app/actions/sessions';
import { db } from '@/lib/prisma';
import { sendManagerSessionApprovalEmail } from '@/lib/email';

// Mock Modules
vi.mock('@/lib/prisma', () => ({
    db: {
        employee: { findUnique: vi.fn() },
        nomination: {
            findFirst: vi.fn(), // Default Mock
            create: vi.fn().mockResolvedValue({ id: 'nom-1' })
        },
        nominationBatch: { findUnique: vi.fn() },
        trainingSession: { findUnique: vi.fn() }
    },
}));

vi.mock('@/lib/email', () => ({
    sendManagerSessionApprovalEmail: vi.fn().mockResolvedValue({ success: true }),
}));

vi.mock('@/auth', () => ({
    auth: vi.fn().mockResolvedValue({ user: { email: 'admin@corp.com' } })
}));

vi.mock('next/cache', () => ({
    revalidatePath: vi.fn(),
    revalidateTag: vi.fn(),
    unstable_cache: (fn: any) => fn
}));

describe('Security & Vulnerability Assessment', () => {
    beforeEach(() => {
        vi.clearAllMocks();
    });

    // --- 1. Race Condition ---
    it('should be VULNERABLE to Race Conditions (Double Join)', async () => {
        const batchId = 'batch-race-1';
        const empId = 'emp-race-1';

        // Setup: Employee exists, Batch exists
        (db.employee.findUnique as any).mockResolvedValue({ id: empId, managerEmail: 'a@b.com' });
        (db.nominationBatch.findUnique as any).mockResolvedValue({
            id: batchId, programId: 'p1', trainingSession: { startDate: new Date(), endDate: new Date() }, program: { name: 'P1' }
        });

        // Setup VULNERABILITY: findFirst always returns NULL (Simulating "Not yet committed")
        // In a race, both threads check DB, both see "Empty", both Insert.
        (db.nomination.findFirst as any).mockResolvedValue(null);

        // Attack: Launch 2 requests exactly in parallel
        await Promise.all([
            joinBatch(batchId, empId),
            joinBatch(batchId, empId)
        ]);

        // Verdict: If safe, create called ONCE. If vulnerable, called TWICE.
        // Current code logic is "Check then Act", so it will be called TWICE in this simulation.
        expect(db.nomination.create).toHaveBeenCalledTimes(2);

        console.log('ðŸš¨ VULNERABILITY CONFIRMED: Race Condition allows duplicate nominations.');
    });
});
